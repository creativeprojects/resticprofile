//go:build !darwin && !windows
// +build !darwin,!windows

package crond

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"os/exec"
	"regexp"
	"strings"
)

const (
	startMarker = "### this content was generated by resticprofile, please leave this line intact ###\n"
	endMarker   = "### end of resticprofile content, please leave this line intact ###\n"
)

type Crontab struct {
	entries []Entry
}

var (
	crontabBinary = "crontab"
)

func NewCrontab(entries []Entry) *Crontab {
	return &Crontab{
		entries: entries,
	}
}

// Update crontab entries:
//
// # If addEntries is set to true, it will delete and add all new entries
//
// # If addEntries is set to false, it will only delete the matching entries
//
// Return values are the number of entries deleted, and an error if any
func (c *Crontab) Update(source string, addEntries bool, w io.StringWriter) (int, error) {
	var err error
	var deleted int

	before, crontab, after, sectionFound := extractOwnSection(source)

	if sectionFound && len(c.entries) > 0 {
		for _, entry := range c.entries {
			var found bool
			crontab, found, err = deleteLine(crontab, entry)
			if err != nil {
				return deleted, err
			}
			if found {
				deleted++
			}
		}
	}

	_, err = w.WriteString(before)
	if err != nil {
		return deleted, err
	}

	if !sectionFound {
		// add a new line at the end of the file before adding our stuff
		_, err = w.WriteString("\n")
		if err != nil {
			return deleted, err
		}
	}

	_, err = w.WriteString(startMarker)
	if err != nil {
		return deleted, err
	}

	if sectionFound {
		_, err = w.WriteString(crontab)
		if err != nil {
			return deleted, err
		}
	}

	if addEntries {
		err = c.Generate(w)
		if err != nil {
			return deleted, err
		}
	}

	_, err = w.WriteString(endMarker)
	if err != nil {
		return deleted, err
	}

	if sectionFound {
		_, err = w.WriteString(after)
		if err != nil {
			return deleted, err
		}
	}
	return deleted, nil
}

func (c *Crontab) Generate(w io.StringWriter) error {
	var err error
	if len(c.entries) > 0 {
		for _, entry := range c.entries {
			err = entry.Generate(w)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (c *Crontab) LoadCurrent() (string, error) {
	buffer := &strings.Builder{}
	cmd := exec.Command(crontabBinary, "-l")
	cmd.Stdout = buffer
	cmd.Stderr = buffer
	err := cmd.Run()
	if err != nil && strings.HasPrefix(buffer.String(), "no crontab for ") {
		// it's ok to be empty
		return "", nil
	} else if err != nil {
		return "", fmt.Errorf("%w: %s", err, buffer.String())
	}
	return cleanupCrontab(buffer.String()), nil
}

func (c *Crontab) Rewrite() error {
	crontab, err := c.LoadCurrent()
	if err != nil {
		return err
	}
	input := &bytes.Buffer{}
	_, err = c.Update(crontab, true, input)
	if err != nil {
		return err
	}

	cmd := exec.Command(crontabBinary, "-")
	cmd.Stdin = input
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	if err != nil {
		return err
	}
	return nil
}

func (c *Crontab) Remove() (int, error) {
	crontab, err := c.LoadCurrent()
	if err != nil {
		return 0, err
	}
	buffer := &bytes.Buffer{}
	num, err := c.Update(crontab, false, buffer)
	if err != nil {
		return num, err
	}

	cmd := exec.Command(crontabBinary, "-")
	cmd.Stdin = buffer
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	if err != nil {
		return num, err
	}
	return num, nil
}

func cleanupCrontab(crontab string) string {
	// this pattern detects if a header has been added to the output of "crontab -l"
	pattern := regexp.MustCompile(`^# DO NOT EDIT THIS FILE[^\n]*\n#[^\n]*\n#[^\n]*\n`)
	// and removes it if found
	return pattern.ReplaceAllString(crontab, "")
}

// extractOwnSection returns before our section, inside, and after if found.
// - It is not returning both start and end markers.
// - If not found, it returns the file content in the first string
func extractOwnSection(crontab string) (string, string, string, bool) {
	start := strings.Index(crontab, startMarker)
	end := strings.Index(crontab, endMarker)
	if start == -1 || end == -1 {
		return crontab, "", "", false
	}
	return crontab[:start], crontab[start+len(startMarker) : end], crontab[end+len(endMarker):], true
}

// deleteLine scans crontab for a line with the same config file, profile name and command name,
// and removes it from the output. It returns true when at least one corresponding line was found.
func deleteLine(crontab string, entry Entry) (string, bool, error) {
	// should match a line like:
	// 00,15,30,45 * * * *	/home/resticprofile --no-ansi --config config.yaml --name profile --log backup.log backup
	// or a line like:
	// 00,15,30,45 * * * *	/home/resticprofile --no-ansi --config config.yaml run-schedule backup@profile
	legacy := fmt.Sprintf(`--name %s[^\n]* %s`,
		regexp.QuoteMeta(entry.profileName),
		regexp.QuoteMeta(entry.commandName),
	)
	runSchedule := fmt.Sprintf(`run-schedule %s@%s`,
		regexp.QuoteMeta(entry.commandName),
		regexp.QuoteMeta(entry.profileName),
	)
	search := fmt.Sprintf(`(?m)^[^#][^\n]+resticprofile[^\n]+--config %s (%s|%s)\n`,
		regexp.QuoteMeta(entry.configFile), legacy, runSchedule)

	pattern, err := regexp.Compile(search)
	if err != nil {
		return crontab, false, err
	}
	if pattern.MatchString(crontab) {
		// al least one was found
		return pattern.ReplaceAllString(crontab, ""), true, nil
	}
	return crontab, false, nil
}
